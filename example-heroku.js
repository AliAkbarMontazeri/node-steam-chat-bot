//Heroku requires a visit to the webpage every hour, or it shuts down the dyno; this bypasses that.
//At the bottom of this file is an example of a basic webserver + pinger to make the bot keep itself alive.
//You need to simply edit the Procfile (if you change the .js filename) and set a config option (APP_URL) pointing to your herokuapp domain before running.
//Visiting the page /stats will result in a simple statistics (same as those generated by the botinfo trigger)
//Visiting the page /stats as a json request will return the same information as json (try it with request using option json:true) 
//Visiting any page ending in log will return that logfile (if it exists). Suggested not to serve *all* pages, as someone could get your config.

//These are needed for the webserver part (see the bottom), which adds some basic stats and serves logs
var express = require("express");
var request = require("request");
var hostname = "localhost"		//set this to the hostname to be used when pinging yourself.  This will not be used if you set an APP_URL env variable in heroku
var localport = 5001;			//set this to the local port expressjs should bind to during testing or in non-heroku situations (the script fetches heroku's APP_PORT automatically)
var startTime = process.hrtime();       //leave this alone
//var username = "";                    //Default is to set a config option for the username and password. Comment out these lines if you intend to run more than one bot or something.
//var password = "";                    //To define config options, use `heroku config:set name=settingvalue`, e.g. username=chatbot or password=50m3_P4w0rD or APP_URL=chatbots.heroku.com
var ChatBot = require('steam-chat-bot').ChatBot;

// This will log in a steam user with the specified username and password 
// You can also pass in a steam guard code from an email

var myBot = new ChatBot(proc.env.username||username, proc.env.password||password, {
//	sentryFile: '',		//Bot tries to find a sentry file automatically. This is only required if you have one with a strange name, otherwise it's automatic.
//	guardCode: '',		//guardCode will override a sentry file. Comment this out after the first use.
	logFile: true,          //set to true to log to bot.$username.log, or define a custom logfile. Set to false if you don't want to log to file.
	autoReconnect: true,    //automatically reconnect to the server
	consoleTime: false,     //don't put timestamps in the console log, `heroku logs` shows them anyways
	consoleColors: false,   //don't use colors in the log. using `heroku logs` will be annoying.
	consoleLogLevel: "warn" //don't log chatter to console, it's spammy. Only log warnings, errors, etc.
});

// Set up the triggers to control the bot
myBot.addTriggers([

	// Commands to stop/unstop the bot from saying anything in a chatroom
	{ 
		name: 'MuteCommand', 
		type: 'BotCommandTrigger', 
		options: { 
			matches: ['!mute', '!pause'], 
			exact: true,
			callback: function(bot) { bot.mute(); }
		} 
	},
	{ 
		name: 'UnmuteCommand', 
		type: 'BotCommandTrigger', 
		options: { 
			matches: ['!unmute', '!unpause'], 
			exact: true,
			callback: function(bot) { bot.unmute(); }
		} 
	},

	// Command to join Bad Rats whenever it's mentioned	
	{ 
		name: 'BadRatsCommand', 
		type: 'BotCommandTrigger', 
		options: { 
			matches: ['bat rats'], 
			exact: false,
			callback: function(bot) { bot.joinGame(34900); }
		} 
	},

	// Automatically accept invites from any user to the specified group chat
	{ 
		name: 'AcceptChatInvite', 
		type: 'AcceptChatInviteTrigger', 
		options: { 
			chatrooms: { 'GroupSteamId': 'Welcome message' }, 
			autoJoinAfterDisconnect: true
		} 
	},

	// Automatically accept all friend requests
	{ name: 'AcceptFriendRequest', type: 'AcceptFriendRequestTrigger' },

	// Reply triggers - respond to a chat/private message if it matches a set of inputs 
	// (case-insensitive exact or substring match), and choose randomly from a set of responses
	{ 
		name: 'EmptyQuoteReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['^'], 
			responses: ['^'], 
			exact: true, 
			delay: 1000, 
			probability: 0.2, 
			timeout: 10*1000 
		} 
	},
	{ 
		name: 'HeartReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['<3'], 
			responses: ['</3', '<3'], 
			exact: true, 
			delay: 500, 
			probability: 0.5, 
			timeout: 60*60*1000 } },
	{ 
		name: 'PingReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['ping'], 
			responses: ['pong'], 
			exact: true, 
			delay: 1000, 
			probability: 1, 
			timeout: 10*1000 } },
/*	you probably don't have :D: or :medicon: emotes on your bot, so this is commented out.
	{ 
		name: 'HealReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['heal','health','heal me',"i'm hurt","I'm hurt",'im hurt','Im hurt'], 
			responses: [':medicon:'], 
			exact: true, 
			delay: 1000, 
			probability: 1, 
			timeout: 10*1000 } },
		name: 'GrinReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: [':D'], 
			responses: [':D:'], 
			exact: true, 
			delay: 500, 
			probability: 0.5, 
			timeout: 60*1000 } },
*/	{ 
		name: 'SteveHoltReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['steve holt', 'steve holt!'], 
			responses: ['\\o/'], 
			exact: false, 
			delay: 500, 
			timeout: 10*1000 
		} 
	},

		name: 'SteamIDCheck', 
		type: 'SteamInfoTrigger', 
		options: { 
			command: "!steamrep", 
			delay: 2000, 
			timeout: 5000 
		} 
	},
	// Reply triggers that will only respond to a particular user
	{ 
		name: 'SingleUserReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: ['hi bot'], 
			responses: ['hi boss!'], 
			exact: true, 
			users: ['76561197961244239'] 
		} 
	},

	// Sample regex trigger, "mate" will be responded to with "mmaaaate", 
	// "mmaaaate" will be responded to with "mmmaaaaaaate", etc
	{ 
		name: 'MateEscalation', 
		type: 'RegexReplaceTrigger',
		options: { match: /^(m+?)(a+?)te(s??)$/, response: '{0}m{1}aaate{2}', delay: 500} 
	},

	// Butt bot, replace a random word from someone's message with "butt" about once every 50 messages
	{ 
		name: 'ButtBot', 
		type: 'ButtBotTrigger', 
		options: { replacement: 'butt', probability: 0.02, delay: 1000 } 
	},

	// Chat reply that doesn't need a particular message to trigger, just a random reply about 
	// once every 100 messages (and no more than once an hour)
	{ 
		name: 'RandomReply', 
		type: 'ChatReplyTrigger', 
		options: { 
			matches: [], 
			responses: ['ლ(ಠ益ಠლ)', 'щ(ﾟДﾟщ)', 'omg', '(ﾉಥ益ಥ)ﾉ', '¯\\_(ツ)_/¯'], 
			delay: 500, 
			probability: 0.01, 
			timeout: 60*60*1000 
		} 
	},

	// Cleverbot reply that only happens when the word "cleverbot" is mentioned
	{ 
		name: 'DirectCleverbotReply', 
		type: 'CleverbotTrigger', 
		options: { keywords: ['cleverbot'] } 
	},

	// Random cleverbot reply that triggers randomly about once every 100 messages
	{ 
		name: 'RandomCleverbotReply', 
		type: 'CleverbotTrigger', 
		options: { probability: 0.01, timeout: 30*60*1000 } 
	},

	// Say something when a user joins chat
	{ 
		name: 'SteveHoltEnter', 
		type: 'MessageOnJoinTrigger', 
		options: { 
			user: '76561197961244239', 
			message: "STEVE HOLT! \\o/", 
			probability: 0.5, 
			delay: 1000, 
			timeout: 24*60*60*1000 
		} 
	},

	// Query Wolfram Alpha when a message starts with !wolfram
	{ 
		name: 'WolframReply', 
		type: 'WolframAlphaTrigger', 
		options: { command: '!wolfram', appId: 'XXXXXX' } 
	},

	//Query Urban Dictionary using their *unofficial* api when a message starts with !urban
	{
		name: 'WolframReply',
		type: 'UrbanDictionaryTrigger',
		options: { command: '!urban' }
	},

	// Post all links from chat to tumblr, and also post things on command
	{ 
		name: 'TumblrTrigger', 
		type: 'TumblrTrigger', 
		options: { 
			autoPost: true, 
			autoPostContext: false, 
			blogName: 'XXX', 
			consumerKey: 'XXX', 
			consumerSecret: 'XXX', 
			token: 'XXX', 
			tokenSecret: 'XXX' 
		}  
	},

	// Search YouTube and respond with the top result whenever someone types !yt <query>, rickroll about 1 every 100 times
	{ 
		name: 'Youtube', 
		type: 'YoutubeTrigger', 
		options: { command: '!yt', rickrollChance: 0.01 } 
	},
]);

myBot.connect();

// Trigger details can be retrieved and reloaded so that external configuration can be supported
var details = myBot.getTriggerDetails();
myBot.clearTriggers();
myBot.addTriggers(details);

//these are useful for displaying your bot as playing a game, so it shows up in the upper part of the userlist.
//this is a comma-separated array of games that the bot will play automatically on login. 440 is tf2.
//myBot.setGames([440]);
//this will stop all games, start the game listed (the first parameter), then after a delay in ms (the second param), start any games it was already playing. 570 is dota2.
//myBot.setPrimaryGame(570,250);














var pingcount = 0;
function getClientIp(req) {
	var ipAddress;
	// Amazon EC2 / Heroku workaround to get real client IP
	var forwardedIpsStr = req.header('x-forwarded-for'); 
	if (forwardedIpsStr) {
		// 'x-forwarded-for' header may return multiple IP addresses in
		// the format: "client IP, proxy 1 IP, proxy 2 IP" so take the
		// the first one
		var forwardedIps = forwardedIpsStr.split(',');
		ipAddress = forwardedIps[0];
	}
	if (!ipAddress) {
		// Ensure getting client IP address still works in
		// development environment
		ipAddress = req.connection.remoteAddress;
	}
	return ipAddress;
};
_bytesToSize = function(bytes) {
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes == 0) return '0 Byte';
    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
}
Number.prototype.toHHMMSS = function () {
	var sec_num = parseInt(this, 10); // don't forget the second param
	var days    = Math.floor(sec_num / 86400);
	var hours   = Math.floor((sec_num - (days * 86400)) / 3600);
	var minutes = Math.floor((sec_num - (days * 86400) - (hours * 3600)) / 60);
	var seconds = sec_num - (days * 86400) - (hours * 3600) - (minutes * 60);

	if (hours   < 10) {hours   = "0"+hours;}
	if (minutes < 10) {minutes = "0"+minutes;}
	if (seconds < 10) {seconds = "0"+seconds;}
	return (days>0?days+":":"")+hours+':'+minutes+':'+seconds;
}
getStats = function() {
	var meminfo = process.memoryUsage();
        var time = process.hrtime(startTime);
            time = time[1] + time[0]*1000000000;
        return {"timeNS":time,"time":(time/1000000000).toHHMMSS(),"platform":process.platform,"arch":process.arch,"heapUsed":meminfo.heapUsed,"heapTotal":meminfo.heapTotal,"rss":meminfo.rss,"version":process.version,"pingcount":pingcount}
}
getStatsString = function() {
	var meminfo = process.memoryUsage();
	var curtime = process.hrtime(startTime);
	curtime = curtime[1] + curtime[0]*1000000000;
	var message  = "I have been running for about " + (curtime/1000000000).toHHMMSS();
	message += " on " + process.platform + "/" + process.arch;
	message += ", using " + _bytesToSize(meminfo.heapUsed) + " of " + _bytesToSize(meminfo.heapTotal) + " allocated memory (RSS: " + _bytesToSize(meminfo.rss);
	message += "). Node.js version is "+process.version+". I have been pinged "+pingcount+" times.";
	return message;
}

_nanosecondsToStr = function(seconds, goagain) {
    var temp = seconds;
    function numberEnding (number) {return (number > 1) ? 's' : '';}

    if(temp > 259200) {
        var temp = Math.floor(temp / 86400);
        var next = (goagain==true ? _nanosecondsToStr(seconds-temp*86400,false) : "");
        return ' ' + temp + ' day' + numberEnding(temp) + next;
    } else if (temp > 10800) {
        var temp = Math.floor(temp / 3600);
        var next = (goagain==true ? _nanosecondsToStr(seconds-temp*3600,false) : "");
        return ' ' + temp + ' hour' + numberEnding(temp) + next;
    } else if (temp > 180) {
        var temp = Math.floor(temp / 60);
        var next = (goagain==true ? _nanosecondsToStr(seconds-temp*60,false) : "");
        return ' ' + temp + ' minute' + numberEnding(temp) + next;
    } else return (goagain==true ? " less than a minute" : "");
}

var app = express();
app.get("/", function(req, res) {
	res.send("This is a private server! You shouldn't be here!");
	console.log(res);
//	console.log(getClientIp(req)+" tried to view us!");
});

app.get("/ping", function(req, res) {
	res.send("Ping count: "+pingcount);
	console.log("Pinged! Count: "+pingcount);
	pingcount++;
});
app.get("/stats", function(req, res) {
	console.log('Accepts JSON?', req.accepts('text/html') !== undefined);
	if(req.accepts('text/html')) 
		res.send(getStatsString());
	else
		res.send(JSON.stringify(getStats()));
	console.log(getClientIp(req)+" retrieved stats");
});
app.get("/stats.js", function(req, res) {
	res.send(JSON.stringify(getStats()));
	console.log(getClientIp(req)+" retrieved stats.js");
});

// serves all the logfiles
app.get(/^(.+.log)$/, function(req, res){ 
	console.log(getClientIp(req)+' requested '+req.params[0]);
	res.sendFile( __dirname + req.params[0]); 
});

var port = process.env.PORT || localport;
app.listen(port, function() {
	console.log("Listening on " + port);
});

var pingself = function(self){
	console.log("Pinging self");
	request.get({method:'GET',encoding:'utf8',uri:"http://"+hostname+"/ping",followAllRedirects:true}, function(error, response, body) {
		if(error) console.log(error);
		else console.log(body);
	});
}
var fetchstats = function(self){
	console.log("Pinging self");
	request.get({method:'GET',encoding:'utf8',uri:"http://"+hostname+"/stats",json:true,followAllRedirects:true}, function(error, response, body) {
		if(error) console.log(error);
		else console.log(body);
	});
}
setInterval(function(){pingself(process.env.APP_URL||"http://"+hostname+":"+remoteport)},1800000);
